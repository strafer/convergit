#!/usr/bin/env sh

set -eu

PROGRAM_NAME="conver"
PROGRAM_VERSION="v0.1.0"

ERRNO_OPERATION_NOT_PERMITTED=1
ERRNO_INVALID_ARGUMENT=22
ERRNO_FUNCTION_NOT_IMPLEMENTED=38

OPTION_COLOR="auto"
OPTION_RECENT_TAG=0
OPTION_CREATE=0
OPTION_PUSH=0
OPTION_REMOTE_NAME="origin"
OPTION_MINOR_TAG=0
OPTION_MAJOR_TAG=0
OPTION_TAG_PREFIX=""
OPTION_TAG_SUFFIX=""
OPTION_CWD="./"
OPTION_VER_DELIM="."
OPTION_ANNOTATED_TAGS=0
OPTION_ANNOTATED_MESSAGE="auto-generated by ${PROGRAM_NAME} ${PROGRAM_VERSION}"
OPTION_DENY_MAJOR=0
OPTION_BRANCH_MAJOR=0
OPTION_BRANCH_MINOR=0
OPTION_TACITURNITY=0
OPTION_INC_MAJOR_BRANCH_NAME=""
OPTION_INC_MAJOR_BRANCH=0
OPTION_CURRENT_BRANCH=""
OPTION_BRANCH_MINOR_DELIMITER="."
OPTION_PUSH_PRE_HOOK=""
OPTION_PUSH_POST_HOOK=""
E_BRANCH="ðŸŒµ "
E_TAG="ðŸ· "
E_COMMIT="ðŸ“ "

if [ "${*#*--debug}" != "${*}" ]; then
  set -x
  export PS4='${LINENO}: '
fi

if [ "${*#*--quiet}" != "${*}" ]; then
  OPTION_TACITURNITY=1
fi

if [ "${*#*--silent}" != "${*}" ]; then
  OPTION_TACITURNITY=2
fi

if [ "${*#*--color}" = "${*}" ]; then
  color_param="${*#*--color[ =]}"
  color_param="${color_param%% *}"
  case ${color_param} in
    auto | always | never )
      OPTION_COLOR="${color_param}"
      ;;

    * )
      OPTION_COLOR="always"
      ;;
  esac
fi

if [ "${OPTION_COLOR}" = "auto" ]; then
  if [ -t 0 ]; then
    OPTION_COLOR="always"
  else
    OPTION_COLOR="never"
  fi
fi

if [ "${OPTION_COLOR}" = "always" ]; then
  C_RED=$'\033[0;31m'
  C_RESET=$'\033[0m'
else
  C_RED=""
  C_RESET=""
fi


log() {
  case ${1} in
    info )
      [ ${OPTION_TACITURNITY} -ne 0 ] || printf "\n%s\n" "${2}"
      ;;

    error )
      [ ${OPTION_TACITURNITY} -ge 2 ] || printf "\n\n${C_RED}ERROR: %s${C_RESET}\n" "${2}" >&2
      ;;

    * )
      log error "unknown logging type '${1}', exit."
      exit ${ERRNO_FUNCTION_NOT_IMPLEMENTED}

  esac
}


PARSED_OPTIONS=$(getopt -o VhcpT:C:A --long version,help,color::,debug,quiet,silent,recent-tag,show-hashes,create,push,git-remote:,git-remote-url:,minor-tag,major-tag,init-tag:,init-commit:,tag-prefix:,respect-pre-release,cwd:,version-delimiter:,annotated-tags,annotated-author:,annotated-email:,annotated-message:,deny-inc-major,inc-major-head-branch,inc-major-branch:,branch-major-prefix:,branch-major-suffix:,branch-minor-prefix:,branch-minor-delimiter:,branch-minor-suffix:,current-branch:,no-emoji,push-pre-hook:,push-post-hook: -n "${PROGRAM_NAME}" -- "$@")

[ $? -eq 0 ] || {
  log error "during options parsing, exit."
  exit ${ERRNO_INVALID_ARGUMENT}
}

eval set -- "${PARSED_OPTIONS}"


show_version() {
  echo "${PROGRAM_NAME}: ${PROGRAM_VERSION}"
}


arguments_help () {
cat << EOF

Ð¡reates git tags according to the semantic versioning standard, based on the
commit messages of the standard of conventional commits.


Helping:
  -h, --help                    Show this info and exit
  -V, --version                 Show program version and exit


Output:

      --color WHEN
          Control colorness of output. WHEN can be one of always, never, or auto
          Without WHEN is the same as '--color always'.
          [default: auto]

      --quiet
          Supress output.
          [default: show all output]

      --silent
          Suppress even errors (but it is still possible to understand the
          success of completion by return codes).
          [default: show all output]

      --show-hashes
          Show commit hashes.
          [default: do not show hashes]

      --no-emoji
          Do not show emoji.
          [default: show emoji]


Tags and branches:

  -T, --tag-prefix PREFIX
          Use the prefix PREFIX before the SemVer itself (f.e., 'v' to form the
          version as 'vX.Y.Z').
          [default: generate versions without any prefix]

      --recent-tag
          Generate only the most recent tag, skipping the intermediates.
          [default: generate a tag for each commit message that changes the
          version according to the ConvCommits]

      --minor-tag
          Generate a tag 'X.Y' corresponding to the most recent tag 'X.Y.Z'.
          With '-c/--create' existing tag 'X.Y' will be deleted and recreated.
          With '-p/--push' tag 'X.Y' will be force-pushed.
          [default: do not generate]

      --major-tag
          Generate a tag 'X' corresponding to the most recent tag 'X.Y.Z'.
          With '-c/--create' existing tag 'X' will be deleted and recreated.
          With '-p/--push' tag 'X' will be force-pushed.
          [default: do not generate]

      --respect-pre-release
          Respect pre-release tags (f.e., 'X.Y.Z-alpha.1') when calculating the
          next version.
          [default: ignore pre-release tags]

      --version-delimiter DELIMITER
          Use <DELIMITER> as the separator character inside the version.
          [default: use dot character]

  -A, --annotated-tags
          Generate annotated tags.
          [default: generate lightweight ones]

      --annotated-author NAME
          Redefine the author of the annotated tags to <NAME>.
          Requires '--annotated-email' option.
          Applies '--generate-annotated' option.
          [default: use the author from the corresponding commit]

      --annotated-email EMAIL
          Redefine the email of the annotated tags to <EMAIL>.
          Requires '--annotated-author' option.
          Applies '--generate-annotated' option.
          [default: use the email from the corresponding commit]

      --annotated-message MSG
          Redefine the message of the annotated tags to <MSG>.
          Applies '--generate-annotated' option.
          [default: "${OPTION_ANNOTATED_MESSAGE}"]

      --deny-inc-major
          Exit with an error when encountering breaking changes.
          [default: raise the major version and continue]

      --inc-major-head-branch
          Allow increasing major version (due breaking changes) only in the
          HEAD branch, if they are found in another branch - exit with an
          error.
          [default: allow increasing major version in any branch]

      --inc-major-branch BRANCH
          Allow increasing major version (due breaking changes) only in the
          branch <BRANCH>, if they are found in another branch - exit with an
          error.
          [default: allow increasing major version in any branch]

      --current-branch BRANCH
          Override the name of the current repository branch.
          [default: use the name of the current branch that HEAD points to]


Repository:
(some of them will CHANGE local and/or remote repositories!)

  -C, --cwd DIR
          Use <DIR> as the root directory of the repository.
          [default: use current directory]

  -c, --create
          Create the resulting tags and branches.
          [default: only show planned tags and branches]

  -p, --push
          Create and push the resulting tags and branches.
          Applies '--create' option.
          [default: do not push, even if something are created locally]

      --push-pre-hook
      --push-post-hook
          Run the command before/after pushing for each tag. The tag name will
          be substituted instead of %t.
          [default: do not run any commands]

      --git-remote-name REMOTE
          Use git remote <REMOTE>.
          Applies '--push' option.
          [default: 'origin']

      --git-remote-url URL
          Set the <URL> for the remote from option '--git-remote-name', creating
          it if it does not exist.
          Applies '--push-tags' option.
          [default: use the URL from the repo settings]

      --branch-major-prefix PREFIX
      --branch-major-prefix SUFFIX
          If
           - any of these options are available
           - the major version needs to be increased
          with the -c/--create option a new branch with a name based on the
          previous major version and these options will be automatically
          created, and with the -p/--push option it will be pushed to a remote
          repository.
          [default: if all these options are missing, do not create branches,
          otherwise empty strings]

      --branch-minor-prefix PREFIX
      --branch-minor-delimiter DELIMITER
      --branch-minor-prefix SUFFIX
          If
           - any of these options are available
           - the minor or major version needs to be increased
          with the -c/--create option a new branch with a name based on the
          previous major and minor version and these options will be
          automatically created, and with the -p/--push option it will be pushed
          to a remote repository.
          [default: if all these options are missing, do not create branches,
          otherwise empty strings except for the delimiter containing the dot
          character]


SemVer tag history initialization:
(applied only if there is no tag corresponding to the SemVer standard)

      --init-tag TAG
          Create a tag <TAG> on the very first commit or on commit with hash
          from '--init-commit' option.
          [default(if <TAG> is an empty string): '0.1.0']

      --init-commit HASH
          Use a commit with the hash HASH as the beginning of the history of
          SemVer tags.
          Applies '--init-tag ""' option.
          [default: starting from the very first commit]

EOF
}



parse_version() {
  local VERSION=${1#${OPTION_TAG_PREFIX}}

  MAJOR=$(echo "${VERSION}" | cut -d"${OPTION_VER_DELIM}" -f1)
  MINOR=$(echo "${VERSION}" | cut -d"${OPTION_VER_DELIM}" -f2)
  PATCH=$(echo "${VERSION}" | cut -d"${OPTION_VER_DELIM}" -f3)
}


parse_message() {
  PREV_HASH=${CURR_HASH}
  PREV_DESC=${CURR_DESC}
  CURR_HASH=$(echo "${1}" | cut -d $'\n' -f 1)
  CURR_DESC=$(echo "${1}" | cut -d $'\n' -f 2)
  CURR_BODY=$(echo "${1}" | tail -n +3)
}


define_tags_authorship() {
  TAG_AUTHOR="${OPTION_ANNOTATED_AUTHOR:-$(${GIT} show -s --format='%aN' ${1})}"
  TAG_EMAIL="${OPTION_ANNOTATED_EMAIL:-$(${GIT} show -s --format='%aE' ${1})}"
}


create_tag() {
  local TAG="${1}"
  local CURR_HASH="${2}"
  if [ ${OPTION_ANNOTATED_TAGS} -eq 0 ]; then
    ${GIT} tag ${TAG} ${CURR_HASH}
  else
    GIT_COMMITTER_NAME="${TAG_AUTHOR}" GIT_COMMITTER_EMAIL="${TAG_EMAIL}" ${GIT} tag ${TAG} -m "${OPTION_ANNOTATED_MESSAGE}" ${CURR_HASH}
  fi
}


add_minor_major_to_list() {
  if echo "${CREATED_MINOR_MAJOR_TAGS}" | grep -vqE "\<${1}\>"; then
    CREATED_MINOR_MAJOR_TAGS="${CREATED_MINOR_MAJOR_TAGS} ${1}"
  fi
}


create_tags() {
  log info "${E_TAG} ${TAG_VALUE}$([ ${OPTION_MINOR_TAG} -eq 0 ] || echo " ${MINOR_TAG}")$([ ${OPTION_MAJOR_TAG} -eq 0 ] || echo " ${MAJOR_TAG}") ${OPTION_SHOW_HASH:+${CURR_HASH} }${CURR_DESC}$([ ${OPTION_ANNOTATED_TAGS} -eq 0 ] || echo " (${TAG_AUTHOR} <${TAG_EMAIL}>)")"

  if [ ${OPTION_CREATE} -eq 1 ]; then
    create_tag ${TAG_VALUE} ${CURR_HASH}
    CREATED_TAGS="${CREATED_TAGS} ${TAG_VALUE}"
    if [ ${OPTION_MINOR_TAG} -eq 1 ]; then
      ${GIT} tag -d ${MINOR_TAG} >/dev/null 2>&1 || true
      create_tag ${MINOR_TAG} ${CURR_HASH}
      add_minor_major_to_list ${MINOR_TAG}
    fi
    if [ ${OPTION_MAJOR_TAG} -eq 1 ]; then
      ${GIT} tag -d ${MAJOR_TAG} >/dev/null 2>&1 || true
      create_tag ${MAJOR_TAG} ${CURR_HASH}
      add_minor_major_to_list ${MAJOR_TAG}
    fi
  fi
}


generate_tags() {
  TAG_VALUE="${OPTION_TAG_PREFIX}${MAJOR}${OPTION_VER_DELIM}${MINOR}${OPTION_VER_DELIM}${PATCH}"
  MINOR_TAG="${OPTION_TAG_PREFIX}${MAJOR}${OPTION_VER_DELIM}${MINOR}"
  MAJOR_TAG="${OPTION_TAG_PREFIX}${MAJOR}"
  if [ ${OPTION_RECENT_TAG} -eq 0 ]; then
    create_tags
  fi
}


create_branch() {
  log info "${E_BRANCH}${1} from ${E_COMMIT}'${PREV_HASH} ${PREV_DESC}' due to a major version change in ${E_COMMIT}'${CURR_HASH} ${CURR_DESC}'"
  if [ ${OPTION_CREATE} -eq 1 ]; then
    ${GIT} branch "${1}" "${PREV_HASH}"
  fi
  CREATED_BRANCHES="${CREATED_BRANCHES} ${BRANCH}"
}


create_branches() {
  local BRANCH=""
  if [ ${OPTION_BRANCH_MAJOR} -eq 1 ]; then
    BRANCH="${OPTION_BRANCH_MAJOR_PREFIX:-}${1}${OPTION_BRANCH_MAJOR_SUFFIX:-}"
    create_branch "${BRANCH}"
  fi
  if [ ${OPTION_BRANCH_MINOR} -eq 1 ]; then
    BRANCH="${OPTION_BRANCH_MINOR_PREFIX:-}${1}${OPTION_BRANCH_MINOR_DELIMITER}${2}${OPTION_BRANCH_MINOR_SUFFIX:-}"
    create_branch "${BRANCH}"
  fi
}


detect_changes() {
  local IS_VERSION_CHANGED=0
  local PREV_MINOR=${MINOR}
  local PREV_MAJOR=${MAJOR}
  if echo "${CURR_DESC}" | grep -qE '^fix(\(|:)'; then
    PATCH=$(( PATCH + 1 ))
    IS_VERSION_CHANGED=1
  fi
  if echo "${CURR_DESC}" | grep -qE '^feat(\(|:)'; then
    MINOR=$(( MINOR + 1 ))
    PATCH=0
    IS_VERSION_CHANGED=1
  fi
  if echo "${CURR_DESC}" | grep -qE '^[^:]+!: ' || echo "${CURR_BODY}" | grep -qE '^BREAKING( |-)CHANGE:'; then
    if [ ${OPTION_DENY_MAJOR} -eq 1 ]; then
      log error "a breaking change was encountered in ${E_COMMIT}'${CURR_HASH} ${CURR_DESC}', but increasing major version $( [ ${OPTION_INC_MAJOR_BRANCH} -eq 1 ] || echo "on branches other than the ${E_BRANCH}'${OPTION_INC_MAJOR_BRANCH_NAME}' ")is denied, exit."
      exit ${ERRNO_OPERATION_NOT_PERMITTED}
    fi
    MAJOR=$(( MAJOR + 1 ))
    MINOR=0
    PATCH=0
    IS_VERSION_CHANGED=1

    if [ $((OPTION_BRANCH_MINOR + OPTION_BRANCH_MAJOR)) -gt 0 ]; then
      create_branches ${PREV_MAJOR} ${PREV_MINOR}
    fi
  fi
  if [ ${IS_VERSION_CHANGED} -eq 1 ]; then
    define_tags_authorship ${CURR_HASH}
    generate_tags
  fi
}


check_symbols() {
  if [ -n "${2//[a-zA-Z0-9._-]/}" ]; then
    log error "the ${1} '${2}' contains a character that is not allowed in the name of the git tag, exit."
    exit ${ERRNO_INVALID_ARGUMENT}
  fi
}

execute_hook() {
  if [ -n "${2}" ]; then
    log info "Execute ${1}-push hooks:"
    for TAG in ${CREATED_TAGS} ${CREATED_MINOR_MAJOR_TAGS}; do
      printf "${E_TAG} ${TAG}: "
      sh -c "${2//%t/${TAG}}"
      echo
    done
  fi
}



while [[ -n "${1:-}" ]]; do
  case "${1}" in
    --debug | --quiet | --silent )
      ;;

    --color )
      shift
      ;;

    -V | --version )
      show_version
      exit 0
      ;;

    -h | --help )
      arguments_help
      exit 0
      ;;

    --recent-tag )
      OPTION_RECENT_TAG=1
      ;;

    --show-hash )
      OPTION_SHOW_HASH=1
      ;;

    -c | --create )
      OPTION_CREATE=1
      ;;

    -p | --push )
      OPTION_CREATE=1
      OPTION_PUSH=1
      ;;

    --git-remote-name )
      OPTION_REMOTE_NAME="${2}"
      OPTION_CREATE=1
      OPTION_PUSH=1
      shift
      ;;

    --git-remote-url )
      OPTION_REMOTE_URL="${2}"
      OPTION_CREATE=1
      OPTION_PUSH=1
      shift
      ;;

    --minor-tag )
      OPTION_MINOR_TAG=1
      ;;

    --major-tag )
      OPTION_MAJOR_TAG=1
      ;;

    --init-tag )
      check_symbols "init tag" "${2}"
      OPTION_INIT_TAG="${2}"
      shift
      ;;

    --init-commit )
      OPTION_INIT_HASH="${2}"
      shift
      ;;

    -T | --tag-prefix )
      check_symbols "prefix" "${2}"
      OPTION_TAG_PREFIX="${2}"
      shift
      ;;

    --respect-pre-release )
      OPTION_TAG_SUFFIX="(-.+)?"
      ;;

    -C | --cwd )
      OPTION_CWD="${2}"
      shift
      ;;

    --version-delimiter )
      if [ ${#2} -ne 1 ]; then
        log error "incorrect separator '${2}', it must be a single character, exit."
        exit ${ERRNO_INVALID_ARGUMENT}
      fi
      check_symbols "separator" "${2}"
      OPTION_VER_DELIM="${2}"
      shift
      ;;

    -A | --annotated-tags )
      OPTION_ANNOTATED_TAGS=1
      ;;

    --annotated-author )
      OPTION_ANNOTATED_TAGS=1
      OPTION_ANNOTATED_AUTHOR="${2}"
      shift
      ;;

    --annotated-email )
      OPTION_ANNOTATED_TAGS=1
      OPTION_ANNOTATED_EMAIL="${2}"
      shift
      ;;

    --annotated-message )
      OPTION_ANNOTATED_TAGS=1
      OPTION_ANNOTATED_MESSAGE="${2}"
      shift
      ;;

    --deny-inc-major )
      OPTION_DENY_MAJOR=1
      ;;

    --inc-major-head-branch )
      OPTION_INC_MAJOR_BRANCH=1
      ;;

    --inc-major-branch )
      OPTION_INC_MAJOR_BRANCH=1
      OPTION_INC_MAJOR_BRANCH_NAME="${2}"
      shift
      ;;

    --branch-major-prefix )
      OPTION_BRANCH_MAJOR=1
      OPTION_BRANCH_MAJOR_PREFIX="${2}"
      shift
      ;;

    --branch-major-suffix )
      OPTION_BRANCH_MAJOR=1
      OPTION_BRANCH_MAJOR_SUFFIX="${2}"
      shift
      ;;

    --branch-minor-prefix )
      OPTION_BRANCH_MINOR=1
      OPTION_BRANCH_MINOR_PREFIX="${2}"
      shift
      ;;

    --branch-minor-delimiter )
      OPTION_BRANCH_MINOR=1
      OPTION_BRANCH_MINOR_DELIMITER="${2}"
      shift
      ;;

    --branch-minor-suffix )
      OPTION_BRANCH_MINOR=1
      OPTION_BRANCH_MINOR_SUFFIX="${2}"
      shift
      ;;

    --current-branch )
      OPTION_CURRENT_BRANCH="${2}"
      shift
      ;;

    --no-emoji )
      E_BRANCH="branch "
      E_TAG="tag "
      E_COMMIT="commit "
      ;;

    --push-pre-hook )
      OPTION_PUSH_PRE_HOOK="${2}"
      shift
      ;;

    --push-post-hook )
      OPTION_PUSH_POST_HOOK="${2}"
      shift
      ;;

    -- )
      ;;

    * )
      log error "processing of argument '${1}' has not been implemented, exit."
      exit ${ERRNO_FUNCTION_NOT_IMPLEMENTED}
      ;;
  esac
  shift
done

if [ ${OPTION_ANNOTATED_TAGS} -eq 1 ] && \
[ -z "${OPTION_ANNOTATED_AUTHOR:-}" -a -n "${OPTION_ANNOTATED_EMAIL:-}" -o -n "${OPTION_ANNOTATED_AUTHOR:-}" -a -z "${OPTION_ANNOTATED_EMAIL:-}" ]; then
  log error "options '--annotated-author' and '--annotated-email' should only be used together, exit."
  exit ${ERRNO_INVALID_ARGUMENT}
fi

GIT="git -C ${OPTION_CWD}"

if ! ${GIT} rev-parse --show-toplevel >/dev/null 2>&1; then
  log error "the directory '${OPTION_CWD}' does not contain a git repository, exit"
  exit ${ERRNO_OPERATION_NOT_PERMITTED}
fi

if [ -z "${OPTION_CURRENT_BRANCH}" ]; then
  OPTION_CURRENT_BRANCH="$(${GIT} rev-parse --abbrev-ref HEAD)"
fi

if [ ${OPTION_INC_MAJOR_BRANCH} -eq 1 -a -z "${OPTION_INC_MAJOR_BRANCH_NAME}" ]; then
  BRANCH=$(${GIT} symbolic-ref --short refs/remotes/${OPTION_REMOTE_NAME}/HEAD 2>/dev/null || true)
  if [ -z "${BRANCH}" ]; then
    BRANCH=$(${GIT} ls-remote --symref ${OPTION_REMOTE_NAME} HEAD 2>/dev/null | awk '/^ref:/ {sub(/refs\/heads\//, "", $2); print $2}' || true)
    if [ -z "${BRANCH}" ]; then
      log error "a symbolic link to the ${E_BRANCH}HEAD was not found in either local or remote, exit."
      exit ${ERRNO_OPERATION_NOT_PERMITTED}
    fi
  else
    BRANCH="${BRANCH##${OPTION_REMOTE_NAME}/}"
  fi
  OPTION_INC_MAJOR_BRANCH_NAME="${BRANCH}"
fi

if [ ${OPTION_INC_MAJOR_BRANCH} -eq 1 ] && [ ! "${OPTION_INC_MAJOR_BRANCH_NAME}" = "${OPTION_CURRENT_BRANCH}" ]; then
  OPTION_DENY_MAJOR=1
fi

if [ ${OPTION_PUSH} -eq 1 ]; then
  if ${GIT} remote get-url "${OPTION_REMOTE_NAME}" >/dev/null 2>&1; then
    if [ -n "${OPTION_REMOTE_URL+x}" ]; then
      ${GIT} remote set-url "${OPTION_REMOTE_NAME}" "${OPTION_REMOTE_URL}" >/dev/null
    fi
  else
    if [ -z "${OPTION_REMOTE_URL+x}" ]; then
      log error "the remote '${OPTION_REMOTE_NAME}' was not found in the git repository configuration, exit."
      exit ${ERRNO_INVALID_ARGUMENT}
    fi
    ${GIT} remote add "${OPTION_REMOTE_NAME}" "${OPTION_REMOTE_URL}" >/dev/null
  fi
fi


MAJOR=""
MINOR=""
PATCH=""
CREATED_TAGS=""
CREATED_MINOR_MAJOR_TAGS=""
CREATED_BRANCHES=""
TAG_VALUE=""
CURR_HASH=""
CURR_DESC=""
MINOR_TAG=""
MAJOR_TAG=""


RECENT_TAG=$(${GIT} log --oneline --simplify-by-decoration --pretty="format:%D" | awk -v prefix="${OPTION_TAG_PREFIX}" -v suffix="${OPTION_TAG_SUFFIX}" -v delim="${OPTION_VER_DELIM}" '
  BEGIN {
    gsub(/./, "\\\\&", delim)
    pattern = "^tag: " prefix "[0-9]+" delim "[0-9]+" delim "[0-9]+" suffix "$"
  }
  {
    delete tags
    n = 0
    split($0, items, ", ")

    for (i in items) {
      if (items[i] ~ pattern) {
        gsub("tag: ", "", items[i])
        tags[n++] = items[i]
      }
    }

    if (n > 0) {
      asort(tags)
      print tags[n]
    }
  }
' | head -n 1)

if [ -z "${RECENT_TAG}" ]; then
  if [ -z "${OPTION_INIT_TAG+x}" ]; then
    log error "no tag matching the semantic versioning standard was found, exit."
    exit ${ERRNO_OPERATION_NOT_PERMITTED}
  else
    if [ -n "${OPTION_INIT_TAG}" ]; then
      if ! echo "${OPTION_INIT_TAG}" | awk -v prefix="${OPTION_TAG_PREFIX}" -v suffix="${OPTION_TAG_SUFFIX}" -v delim="${OPTION_VER_DELIM}" '{
        gsub(/./, "\\\\&", delim)
        pattern = "^" prefix "[0-9]+" delim "[0-9]+" delim "[0-9]+" suffix "$"
        if ($0 !~ pattern) {
          exit 22
        }
      }'; then
        log error "the specified initial tag '${OPTION_INIT_TAG}' does not meet the criteria for semantic versioning, exit."
        exit ${ERRNO_INVALID_ARGUMENT}
      fi
    else
      OPTION_INIT_TAG="${OPTION_TAG_PREFIX}0${OPTION_VER_DELIM}1${OPTION_VER_DELIM}0"
    fi
    parse_version ${OPTION_INIT_TAG}
    if [ -z "${OPTION_INIT_HASH:-}" ]; then
      INIT_HASH="$(${GIT} rev-list --max-parents=0 HEAD)"
    else
      if ! ${GIT} merge-base --is-ancestor "${OPTION_INIT_HASH}" HEAD >/dev/null 2>&1; then
        log error "the commit with the hash '${OPTION_INIT_HASH}' was not found in the current branch, exit."
        exit ${ERRNO_INVALID_ARGUMENT}
      fi
      INIT_HASH="${OPTION_INIT_HASH}"
    fi
    parse_message "$(${GIT} log ${INIT_HASH} --pretty=format:"%H%n%B")"
    define_tags_authorship ${INIT_HASH}
    generate_tags
    RECENT_TAG=${INIT_HASH}
  fi
else
  parse_message "$(${GIT} log ${RECENT_TAG} --pretty=format:"%H%n%B")"
  parse_version ${RECENT_TAG}
fi

FIFO=$(mktemp -u)
mkfifo "${FIFO}"
${GIT} log ${RECENT_TAG}..HEAD --reverse --pretty=format:"%H%n%B%x00" > "${FIFO}" &
while read -r -d $'\0' COMMIT; do
  parse_message "${COMMIT}"
  detect_changes
done < "${FIFO}"
rm "${FIFO}"

if [ -n "${TAG_VALUE}" ]; then
  if [ ${OPTION_RECENT_TAG} -eq 1 ]; then
    create_tags
  fi

  if [ ${OPTION_PUSH} -eq 1 ]; then
    if ${GIT} remote show ${OPTION_REMOTE_NAME} >/dev/null; then
      if [ -n "${CREATED_BRANCHES}" ]; then
        log info "Pushing created branches: ${CREATED_BRANCHES}"
        ${GIT} push ${OPTION_REMOTE_NAME} ${CREATED_BRANCHES}
      fi

      execute_hook "pre" "${OPTION_PUSH_PRE_HOOK}"

      log info "Push created tags: ${CREATED_TAGS}"
      # ${GIT} push ${OPTION_REMOTE_NAME} ${CREATED_TAGS}
      echo ${GIT} push ${OPTION_REMOTE_NAME} ${CREATED_TAGS}

      if [ -n "${CREATED_MINOR_MAJOR_TAGS}" ]; then
        log info "Pushing created $([ ${OPTION_MINOR_TAG} -eq 0 ] || echo "minor ")$([ ${OPTION_MAJOR_TAG} -eq 0 ] || echo "major ")tags: ${CREATED_MINOR_MAJOR_TAGS}"
        # ${GIT} push --force ${OPTION_REMOTE_NAME} ${CREATED_MINOR_MAJOR_TAGS} >/dev/null
        echo ${GIT} push --force ${OPTION_REMOTE_NAME} ${CREATED_MINOR_MAJOR_TAGS} >/dev/null
      fi

      execute_hook "post" "${OPTION_PUSH_PRE_HOOK}"
    else
      log error "there is no connected remote '${OPTION_REMOTE_NAME}'"
      exit ${ERRNO_OPERATION_NOT_PERMITTED}
    fi
  fi
else
  log info "No tags were generated."
  exit 0
fi
